<!DOCTYPE html>
<html>
<head>
  <title>OBBY ONLINE</title>
  <style>
    body { margin:0; overflow:hidden; font-family:Arial; }
    canvas { display:block; }

    #chatToggle {
      position: fixed;
      bottom: 20px;
      left: 20px;
      width: 50px;
      height: 50px;
      background: rgba(0,0,0,0.6);
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 22px;
      cursor: pointer;
      user-select: none;
    }

    #chatContainer {
      position: fixed;
      bottom: 80px;
      left: 20px;
      width: 300px;
      background: rgba(0,0,0,0.6);
      padding: 10px;
      border-radius: 12px;
      display: none;
      color: white;
    }

    #chatBox {
      max-height: 150px;
      overflow-y: auto;
      font-size: 14px;
      margin-bottom: 5px;
    }

    #chatInput {
      width: 100%;
      padding: 5px;
      box-sizing: border-box;
    }
  </style>
</head>
<body>

<div id="chatToggle">üí¨</div>

<div id="chatContainer">
  <div id="chatBox"></div>
  <input id="chatInput" placeholder="–ù–∞–ø–∏—Å–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ...">
</div>

<script src="/socket.io/socket.io.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>

<script>
const socket = io();

// ================= THREE =================
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87CEEB);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

scene.add(new THREE.AmbientLight(0xffffff,0.6));
const light = new THREE.DirectionalLight(0xffffff,1);
light.position.set(5,10,5);
scene.add(light);

// ================= –ü–õ–ê–¢–§–û–†–ú–´ =================
const platforms=[];

function createPlatform(x,y,z,w,h,d,color=0x808080){
  const mesh=new THREE.Mesh(
    new THREE.BoxGeometry(w,h,d),
    new THREE.MeshStandardMaterial({color})
  );
  mesh.position.set(x,y,z);
  scene.add(mesh);
  platforms.push(mesh);
}

createPlatform(0,0,0,10,1,10);
createPlatform(0,3,-10,4,1,4,0xffaa00);
createPlatform(5,6,-20,4,1,4,0xffaa00);
createPlatform(-5,9,-30,4,1,4,0xffaa00);
createPlatform(0,12,-40,4,1,4,0x00ff00);

// ================= –ò–ì–†–û–ö =================
const player=new THREE.Mesh(
  new THREE.BoxGeometry(1,2,1),
  new THREE.MeshStandardMaterial({color:0xff0000})
);
player.position.set(0,2,0);
scene.add(player);

let velocityY=0;
let isOnGround=false;
const gravity=-0.01;
const jumpPower=0.25;

// ================= –£–ü–†–ê–í–õ–ï–ù–ò–ï (–ù–ï–ó–ê–í–ò–°–ò–ú–û –û–¢ –Ø–ó–´–ö–ê) =================
const keys={};
let isTyping=false;

document.addEventListener("keydown",e=>{
  keys[e.code]=true;
});

document.addEventListener("keyup",e=>{
  keys[e.code]=false;
});

// ================= –ö–ê–ú–ï–†–ê =================
let yaw=0;
let pitch=0;
let isRightMouseDown=false;

document.addEventListener("contextmenu",e=>e.preventDefault());
document.addEventListener("mousedown",e=>{
  if(e.button===2) isRightMouseDown=true;
});
document.addEventListener("mouseup",e=>{
  if(e.button===2) isRightMouseDown=false;
});
document.addEventListener("mousemove",e=>{
  if(isRightMouseDown && !isTyping){
    yaw-=e.movementX*0.002;
    pitch-=e.movementY*0.002;
    pitch=Math.max(-1.5,Math.min(1.5,pitch));
  }
});

// ================= –ß–ê–¢ =================
const chatToggle=document.getElementById("chatToggle");
const chatContainer=document.getElementById("chatContainer");
const chatBox=document.getElementById("chatBox");
const chatInput=document.getElementById("chatInput");

let chatTimeout=null;

function openChat(){
  chatContainer.style.display="block";
  isTyping=true;
  chatInput.focus();
  resetTimer();
}

function closeChat(){
  chatContainer.style.display="none";
  isTyping=false;
  chatInput.blur();
}

function resetTimer(){
  if(chatTimeout) clearTimeout(chatTimeout);
  chatTimeout=setTimeout(()=>{
    if(document.activeElement!==chatInput){
      closeChat();
    }
  },4000);
}

chatToggle.addEventListener("click",()=>{
  if(chatContainer.style.display==="block"){
    closeChat();
  } else {
    openChat();
  }
});

chatInput.addEventListener("keydown",e=>{
  resetTimer();
  if(e.key==="Enter" && chatInput.value.trim()!==""){
    socket.emit("chatMessage",chatInput.value);
    chatInput.value="";
  }
});

chatInput.addEventListener("blur",()=>{
  isTyping=false;
  resetTimer();
});

socket.on("chatMessage",data=>{
  openChat();
  const msg=document.createElement("div");
  msg.textContent=data.id.slice(0,4)+": "+data.message;
  chatBox.appendChild(msg);
  chatBox.scrollTop=chatBox.scrollHeight;
  resetTimer();
});

// ================= –ú–£–õ–¨–¢–ò–ü–õ–ï–ï–† =================
const otherPlayers={};

function addOtherPlayer(id,data){
  const mesh=new THREE.Mesh(
    new THREE.BoxGeometry(1,2,1),
    new THREE.MeshStandardMaterial({color:0x00ff00})
  );
  mesh.position.set(data.x,data.y,data.z);
  scene.add(mesh);
  otherPlayers[id]=mesh;
}

socket.on("currentPlayers",players=>{
  for(let id in players){
    if(id!==socket.id) addOtherPlayer(id,players[id]);
  }
});

socket.on("newPlayer",data=>addOtherPlayer(data.id,data.player));

socket.on("playerMoved",data=>{
  if(otherPlayers[data.id]){
    otherPlayers[data.id].position.set(data.player.x,data.player.y,data.player.z);
  }
});

socket.on("playerDisconnected",id=>{
  if(otherPlayers[id]){
    scene.remove(otherPlayers[id]);
    delete otherPlayers[id];
  }
});

// ================= –§–ò–ó–ò–ö–ê =================
function checkCollision(){
  isOnGround=false;
  for(let p of platforms){
    const dx=Math.abs(player.position.x-p.position.x);
    const dz=Math.abs(player.position.z-p.position.z);
    if(dx<p.geometry.parameters.width/2 &&
       dz<p.geometry.parameters.depth/2){
      const top=p.position.y+0.5;
      if(player.position.y-1<=top &&
         player.position.y-1>=top-0.5){
        player.position.y=top+1;
        velocityY=0;
        isOnGround=true;
      }
    }
  }
}

function animate(){
  requestAnimationFrame(animate);

  const speed=0.15;

  if(!isTyping){

    if(keys["KeyW"]){
      player.position.x-=Math.sin(yaw)*speed;
      player.position.z-=Math.cos(yaw)*speed;
    }

    if(keys["KeyS"]){
      player.position.x+=Math.sin(yaw)*speed;
      player.position.z+=Math.cos(yaw)*speed;
    }

    if(keys["KeyA"]){
      player.position.x-=Math.cos(yaw)*speed;
      player.position.z+=Math.sin(yaw)*speed;
    }

    if(keys["KeyD"]){
      player.position.x+=Math.cos(yaw)*speed;
      player.position.z-=Math.sin(yaw)*speed;
    }

    if(keys["Space"] && isOnGround){
      velocityY=jumpPower;
    }
  }

  velocityY+=gravity;
  player.position.y+=velocityY;

  checkCollision();

  if(player.position.y<-20){
    player.position.set(0,2,0);
    velocityY=0;
  }

  const dist=10;
  camera.position.x=player.position.x+Math.sin(yaw)*dist*Math.cos(pitch);
  camera.position.z=player.position.z+Math.cos(yaw)*dist*Math.cos(pitch);
  camera.position.y=player.position.y+Math.sin(pitch)*dist+3;
  camera.lookAt(player.position);

  socket.emit("updatePosition",{
    x:player.position.x,
    y:player.position.y,
    z:player.position.z
  });

  renderer.render(scene,camera);
}

animate();
</script>
</body>
</html>
