<!DOCTYPE html>
<html>
<head>
  <title>OBBY ONLINE</title>
  <style>
    body { margin:0; overflow:hidden; font-family:Arial; }
    canvas { display:block; }
    #chatBox {
      position: fixed;
      bottom: 40px;
      left: 10px;
      width: 300px;
      max-height: 200px;
      overflow-y: auto;
      background: rgba(0,0,0,0.5);
      color: white;
      padding: 10px;
      font-size: 14px;
    }
    #chatInput {
      position: fixed;
      bottom: 10px;
      left: 10px;
      width: 300px;
      padding: 5px;
      box-sizing: border-box;
    }
  </style>
</head>
<body>

<div id="chatBox"></div>
<input id="chatInput" placeholder="Написать сообщение...">

<script src="/socket.io/socket.io.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>

<script>
const socket = io();

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87CEEB);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

scene.add(new THREE.AmbientLight(0xffffff, 0.6));
const light = new THREE.DirectionalLight(0xffffff, 1);
light.position.set(5,10,5);
scene.add(light);

// ================== ПЛАТФОРМЫ ==================
const platforms = [];

function createPlatform(x,y,z,w,h,d,color=0x808080){
  const mesh = new THREE.Mesh(
    new THREE.BoxGeometry(w,h,d),
    new THREE.MeshStandardMaterial({color})
  );
  mesh.position.set(x,y,z);
  scene.add(mesh);
  platforms.push(mesh);
}

createPlatform(0,0,0,10,1,10);
createPlatform(0,3,-10,4,1,4,0xffaa00);
createPlatform(5,6,-20,4,1,4,0xffaa00);
createPlatform(-5,9,-30,4,1,4,0xffaa00);
createPlatform(0,12,-40,4,1,4,0x00ff00);

// ================== ИГРОК ==================
const player = new THREE.Mesh(
  new THREE.BoxGeometry(1,2,1),
  new THREE.MeshStandardMaterial({color:0xff0000})
);
player.position.set(0,2,0);
scene.add(player);

let velocityY = 0;
let isOnGround = false;
const gravity = -0.01;
const jumpPower = 0.25;

const keys = {};
document.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
document.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

let yaw = 0;
let pitch = 0;
let isRightMouseDown = false;

document.addEventListener("contextmenu", e => e.preventDefault());
document.addEventListener("mousedown", e => { if(e.button===2) isRightMouseDown=true; });
document.addEventListener("mouseup", e => { if(e.button===2) isRightMouseDown=false; });
document.addEventListener("mousemove", e=>{
  if(isRightMouseDown){
    yaw -= e.movementX*0.002;
    pitch -= e.movementY*0.002;
    pitch = Math.max(-1.5, Math.min(1.5, pitch));
  }
});

// ================== МУЛЬТИПЛЕЕР ==================
const otherPlayers = {};

function addOtherPlayer(id,data){
  const mesh = new THREE.Mesh(
    new THREE.BoxGeometry(1,2,1),
    new THREE.MeshStandardMaterial({color:0x00ff00})
  );
  mesh.position.set(data.x,data.y,data.z);
  scene.add(mesh);
  otherPlayers[id]=mesh;
}

socket.on("currentPlayers", players=>{
  for(let id in players){
    if(id!==socket.id) addOtherPlayer(id,players[id]);
  }
});
socket.on("newPlayer", data=>addOtherPlayer(data.id,data.player));
socket.on("playerMoved", data=>{
  if(otherPlayers[data.id]){
    otherPlayers[data.id].position.set(data.player.x,data.player.y,data.player.z);
  }
});
socket.on("playerDisconnected", id=>{
  if(otherPlayers[id]){
    scene.remove(otherPlayers[id]);
    delete otherPlayers[id];
  }
});

// ================== ЧАТ ==================
const chatBox = document.getElementById("chatBox");
const chatInput = document.getElementById("chatInput");

chatInput.addEventListener("keydown", (e)=>{
  if(e.key==="Enter" && chatInput.value.trim()!==""){
    socket.emit("chatMessage", chatInput.value);
    chatInput.value="";
  }
});

socket.on("chatMessage", data=>{
  const msg=document.createElement("div");
  msg.textContent=data.id.slice(0,4)+": "+data.message;
  chatBox.appendChild(msg);
  chatBox.scrollTop=chatBox.scrollHeight;
});

// ================== ФИЗИКА ==================
function checkCollision(){
  isOnGround=false;
  for(let p of platforms){
    const dx=Math.abs(player.position.x-p.position.x);
    const dz=Math.abs(player.position.z-p.position.z);
    if(dx<p.geometry.parameters.width/2 &&
       dz<p.geometry.parameters.depth/2){
      const top=p.position.y+0.5;
      if(player.position.y-1<=top &&
         player.position.y-1>=top-0.5){
        player.position.y=top+1;
        velocityY=0;
        isOnGround=true;
      }
    }
  }
}

function animate(){
  requestAnimationFrame(animate);

  const speed=0.15;

  if(keys["w"]){
    player.position.x-=Math.sin(yaw)*speed;
    player.position.z-=Math.cos(yaw)*speed;
  }
  if(keys["s"]){
    player.position.x+=Math.sin(yaw)*speed;
    player.position.z+=Math.cos(yaw)*speed;
  }
  if(keys["a"]){
    player.position.x-=Math.cos(yaw)*speed;
    player.position.z+=Math.sin(yaw)*speed;
  }
  if(keys["d"]){
    player.position.x+=Math.cos(yaw)*speed;
    player.position.z-=Math.sin(yaw)*speed;
  }

  if(keys[" "] && isOnGround){
    velocityY=jumpPower;
  }

  velocityY+=gravity;
  player.position.y+=velocityY;

  checkCollision();

  if(player.position.y<-20){
    player.position.set(0,2,0);
    velocityY=0;
  }

  const dist=10;
  camera.position.x=player.position.x+Math.sin(yaw)*dist*Math.cos(pitch);
  camera.position.z=player.position.z+Math.cos(yaw)*dist*Math.cos(pitch);
  camera.position.y=player.position.y+Math.sin(pitch)*dist+3;
  camera.lookAt(player.position);

  socket.emit("updatePosition",{
    x:player.position.x,
    y:player.position.y,
    z:player.position.z
  });

  renderer.render(scene,camera);
}

animate();
</script>
</body>
</html>
